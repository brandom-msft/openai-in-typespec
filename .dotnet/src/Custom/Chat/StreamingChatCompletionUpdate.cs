namespace OpenAI.Chat;

using System;
using System.Collections.Generic;
using System.Text.Json;

/// <summary>
/// Represents an incremental item of new data in a streaming response to a chat completion request.
/// </summary>
[CodeGenModel("CreateChatCompletionStreamResponse")]
public partial class StreamingChatCompletionUpdate
{
    private IReadOnlyList<ChatMessageContentPart> _contentUpdate;
    private IReadOnlyList<StreamingChatToolCallUpdate> _toolCallUpdates;

    // CUSTOM:
    // - Made private. This property does not add value in the context of a strongly-typed class.
    // - Changed type from string.
    /// <summary> The object type, which is always `chat.completion.chunk`. </summary>
    [CodeGenMember("Object")]
    internal InternalCreateChatCompletionStreamResponseObject Object { get; } = InternalCreateChatCompletionStreamResponseObject.ChatCompletionChunk;

    // CUSTOM: Made internal.We only get back a single choice, and instead we flatten the structure for usability.
    /// <summary>
    /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
    /// last chunk if you set `stream_options: {"include_usage": true}`.
    /// </summary>
    [CodeGenMember("Choices")] 
    internal IReadOnlyList<InternalCreateChatCompletionStreamResponseChoice> Choices { get; }

    // CUSTOM: Renamed.
    /// <summary> The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp. </summary>
    [CodeGenMember("Created")]
    public DateTimeOffset CreatedAt { get; }

    // CUSTOM: Changed type from InternalCreateChatCompletionStreamResponseUsage.
    /// <summary>
    /// An optional field that will only be present when you set `stream_options: {"include_usage": true}` in your request.
    /// When present, it contains a null value except for the last chunk which contains the token usage statistics for the entire request.
    /// </summary>
    [CodeGenMember("Usage")]
    public ChatTokenUsage Usage { get; }

    // CUSTOM: Flattened choice property.
    /// <summary>
    /// Gets the <see cref="ChatFinishReason"/> associated with this update.
    /// </summary>
    public ChatFinishReason? FinishReason => (Choices.Count > 0)
        ? Choices[0].FinishReason 
        : null;

    // CUSTOM: Flattened choice property.
    /// <summary>
    /// The log probability information for choices in the chat completion response, as requested via
    /// <see cref="ChatCompletionOptions.IncludeLogProbabilities"/>.
    /// </summary>
    public ChatLogProbabilityInfo LogProbabilityInfo => (Choices.Count > 0)
        ? Choices[0].Logprobs
        : null;

    /// <summary>
    /// Gets the content fragment associated with this update.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Corresponds to e.g. <c>$.choices[0].delta.content</c> in the underlying REST schema.
    /// </para>
    /// Each update contains only a small number of tokens. When presenting or reconstituting a full, streamed
    /// response, all <see cref="ContentUpdate"/> values for the same chat completions should be combined.
    /// </remarks>
    public IReadOnlyList<ChatMessageContentPart> ContentUpdate => (Choices.Count > 0)
        ? Choices[0].Delta.Content
        : _contentUpdate ??= new ChangeTrackingList<ChatMessageContentPart>();

    // CUSTOM: Flattened choice delta property.
    /// <summary>
    /// Gets the <see cref="ChatMessageRole"/> associated with this update.
    /// </summary>
    /// <remarks>
    /// <see cref="ChatMessageRole"/> assignment typically occurs in a single update across a streamed Chat Completions
    /// and the value should be considered to be persist for all subsequent updates.
    /// </remarks>
    public ChatMessageRole? Role => (Choices.Count > 0)
        ? Choices[0].Delta.Role
        : null;

    // CUSTOM: Flattened choice delta property.
    /// <summary> Gets the tool calls. </summary>
    public IReadOnlyList<StreamingChatToolCallUpdate> ToolCallUpdates => (Choices.Count > 0)
        ? Choices[0].Delta.ToolCalls
        : _toolCallUpdates ??= new ChangeTrackingList<StreamingChatToolCallUpdate>();

    // CUSTOM: Flattened choice delta property.
    /// <summary>
    /// Deprecated and replaced by <see cref="ToolCallUpdates"/>. The name and arguments of a function that
    /// should be called, as generated by the model.
    /// </summary>
    public StreamingChatFunctionCallUpdate FunctionCallUpdate => (Choices.Count > 0)
        ? Choices[0].Delta.FunctionCall
        : null;

    internal static List<StreamingChatCompletionUpdate> DeserializeStreamingChatCompletionUpdates(JsonElement element)
    {
        return [StreamingChatCompletionUpdate.DeserializeStreamingChatCompletionUpdate(element)];
    }

    // TODO
    //internal static List<StreamingChatUpdate> DeserializeStreamingChatCompletionUpdates(JsonElement element)
    //{
    //    List<StreamingChatUpdate> results = [];
    //    if (element.ValueKind == JsonValueKind.Null)
    //    {
    //        return results;
    //    }
    //    string id = default;
    //    DateTimeOffset created = default;
    //    string systemFingerprint = null;
    //    ChatTokenUsage usage = null;
    //    foreach (JsonProperty property in element.EnumerateObject())
    //    {
    //        if (property.NameEquals("id"u8))
    //        {
    //            id = property.Value.GetString();
    //            continue;
    //        }
    //        if (property.NameEquals("created"u8))
    //        {
    //            created = DateTimeOffset.FromUnixTimeSeconds(property.Value.GetInt64());
    //            continue;
    //        }
    //        if (property.NameEquals("system_fingerprint"))
    //        {
    //            systemFingerprint = property.Value.GetString();
    //            continue;
    //        }
    //        if (property.NameEquals("usage") && property.Value.ValueKind == JsonValueKind.Object)
    //        {
    //            Internal.Models.CreateChatCompletionStreamResponseUsage streamingUsage
    //                = Internal.Models.CreateChatCompletionStreamResponseUsage
    //                    .DeserializeCreateChatCompletionStreamResponseUsage(property.Value);
    //            usage = new(streamingUsage.PromptTokens, streamingUsage.CompletionTokens, streamingUsage.TotalTokens);
    //            continue;
    //        }
    //        if (property.NameEquals("choices"u8))
    //        {
    //            foreach (JsonElement choiceElement in property.Value.EnumerateArray())
    //            {
    //                ChatMessageRole? role = null;
    //                string contentUpdate = null;
    //                string functionName = null;
    //                string functionArgumentsUpdate = null;
    //                int choiceIndex = 0;
    //                ChatFinishReason? finishReason = null;
    //                List<StreamingToolCallUpdate> toolCallUpdates = [];
    //                // ChatLogProbabilityCollection logProbabilities = new([]);

    //                foreach (JsonProperty choiceProperty in choiceElement.EnumerateObject())
    //                {
    //                    if (choiceProperty.NameEquals("index"u8))
    //                    {
    //                        choiceIndex = choiceProperty.Value.GetInt32();
    //                        continue;
    //                    }
    //                    if (choiceProperty.NameEquals("finish_reason"u8))
    //                    {
    //                        if (choiceProperty.Value.ValueKind == JsonValueKind.Null)
    //                        {
    //                            finishReason = null;
    //                            continue;
    //                        }
    //                        finishReason = choiceProperty.Value.GetString() switch
    //                        {
    //                            "stop" => ChatFinishReason.Stop,
    //                            "length" => ChatFinishReason.Length,
    //                            "tool_calls" => ChatFinishReason.ToolCalls,
    //                            "function_call" => ChatFinishReason.FunctionCall,
    //                            "content_filter" => ChatFinishReason.ContentFilter,
    //                            _ => throw new ArgumentException(nameof(finishReason)),
    //                        };
    //                        continue;
    //                    }
    //                    if (choiceProperty.NameEquals("delta"u8))
    //                    {
    //                        foreach (JsonProperty deltaProperty in choiceProperty.Value.EnumerateObject())
    //                        {
    //                            if (deltaProperty.NameEquals("role"u8))
    //                            {
    //                                role = deltaProperty.Value.GetString() switch
    //                                {
    //                                    "system" => ChatMessageRole.System,
    //                                    "user" => ChatMessageRole.User,
    //                                    "assistant" => ChatMessageRole.Assistant,
    //                                    "tool" => ChatMessageRole.Tool,
    //                                    "function" => ChatMessageRole.Function,
    //                                    _ => throw new ArgumentException(nameof(role)),
    //                                };
    //                                continue;
    //                            }
    //                            if (deltaProperty.NameEquals("content"u8))
    //                            {
    //                                contentUpdate = deltaProperty.Value.GetString();
    //                                continue;
    //                            }
    //                            if (deltaProperty.NameEquals("function_call"u8))
    //                            {
    //                                foreach (JsonProperty functionProperty in deltaProperty.Value.EnumerateObject())
    //                                {
    //                                    if (functionProperty.NameEquals("name"u8))
    //                                    {
    //                                        functionName = functionProperty.Value.GetString();
    //                                        continue;
    //                                    }
    //                                    if (functionProperty.NameEquals("arguments"u8))
    //                                    {
    //                                        functionArgumentsUpdate = functionProperty.Value.GetString();
    //                                    }
    //                                }
    //                            }
    //                            if (deltaProperty.NameEquals("tool_calls"))
    //                            {
    //                                foreach (JsonElement toolCallElement in deltaProperty.Value.EnumerateArray())
    //                                {
    //                                    toolCallUpdates.Add(
    //                                        StreamingToolCallUpdate.DeserializeStreamingToolCallUpdate(toolCallElement));
    //                                }
    //                            }
    //                        }
    //                    }
    //                    //if (choiceProperty.NameEquals("logprobs"u8))
    //                    //{
    //                    //    Internal.Models.CreateChatCompletionResponseChoiceLogprobs internalLogprobs
    //                    //        = Internal.Models.CreateChatCompletionResponseChoiceLogprobs.DeserializeCreateChatCompletionResponseChoiceLogprobs(
    //                    //            choiceProperty.Value);
    //                    //    logProbabilities = ChatLogProbabilityCollection.FromInternalData(internalLogprobs);
    //                    //}
    //                }
    //                // In the unlikely event that more than one tool call arrives on a single chunk, we'll generate
    //                // separate updates just like for choices. Adding a "null" if empty lets us avoid a separate loop.
    //                if (toolCallUpdates.Count == 0)
    //                {
    //                    toolCallUpdates.Add(null);
    //                }
    //                foreach (StreamingToolCallUpdate toolCallUpdate in toolCallUpdates)
    //                {
    //                    results.Add(new StreamingChatUpdate(
    //                        id,
    //                        created,
    //                        systemFingerprint,
    //                        usage,
    //                        choiceIndex,
    //                        role,
    //                        contentUpdate,
    //                        finishReason,
    //                        functionName,
    //                        functionArgumentsUpdate,
    //                        toolCallUpdate));
    //                }
    //            }
    //            continue;
    //        }
    //    }
    //    if (results.Count == 0)
    //    {
    //        results.Add(new StreamingChatUpdate(id, created, systemFingerprint, usage));
    //    }
    //    return results;
    //}
}
